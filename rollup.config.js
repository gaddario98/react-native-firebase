import peerDepsExternal from "rollup-plugin-peer-deps-external";
import { nodeResolve } from "@rollup/plugin-node-resolve";
import commonjs from "@rollup/plugin-commonjs";
import typescript from "@rollup/plugin-typescript";
import json from "@rollup/plugin-json";
import babel from "@rollup/plugin-babel";

// Centralized list of entry points. Each becomes dist/<name>/index.mjs (except root index)
// Keep this list in sync with package.json exports.

const entries = [
  { name: "index", input: "index.ts", useNative: true }, // Special case: creates both index.mjs and index.native.mjs
  { name: "ui", input: "ui/index.ts" },
  { name: "native", input: "native/index.ts" },
  { name: "web", input: "web/index.ts" },
];

// Extra externals that might not be declared as peer deps but should not be bundled.
const extraExternal = [
  "react",
  "react/jsx-runtime",
  "react-native",
  "@react-native-firebase/app",
  "@react-native-firebase/auth",
  "firebase/app",
  "firebase/auth",
];

const extensions = [".mjs", ".js", ".json", ".ts", ".tsx"];

// Produce one config per entry (tree-shaking friendly, small output bundles)
/** @type {import('rollup').RollupOptions[]} */
const config = entries.flatMap(({ name, input, useNative }) => {
  const configs = [];

  // Standard config for web/universal
  configs.push({
    input,
    output: [
      {
        file: name === "index" ? `dist/index.mjs` : `dist/${name}/index.mjs`,
        format: "esm",
        sourcemap: true,
      },
    ],
    external: extraExternal,
    treeshake: {
      moduleSideEffects: false,
    },
    plugins: [
      peerDepsExternal(), // auto-mark peer deps as external
      nodeResolve({
        extensions: [".ts", ".tsx", ".js", ".jsx"],
        preferBuiltins: false,
        browser: true,
      }),
      commonjs(),
      typescript({
        tsconfig: "./tsconfig.json",
        declaration: name === "index", // Only generate declarations for main entry
        declarationDir: name === "index" ? "dist" : undefined,
        declarationMap: false,
        noForceEmit: true,
      }),
      json(),
      babel({
        extensions: [".js", ".jsx", ".ts", ".tsx"],
        plugins: ["babel-plugin-react-compiler"],
        babelHelpers: "bundled",
      }),
    ],
    onwarn(warning, warn) {
      // Reduce noise for common benign warnings; forward others.
      if (warning.code === "THIS_IS_UNDEFINED") return;
      warn(warning);
    },
  });

  // Native config for React Native (only for main index)
  if (useNative) {
    configs.push({
      input: "index.native.ts", // Use the native entry point
      output: [
        {
          file: `dist/index.native.mjs`,
          format: "esm",
          sourcemap: true,
        },
      ],
      external: extraExternal,
      treeshake: {
        moduleSideEffects: false,
      },
      plugins: [
        peerDepsExternal(),
        nodeResolve({
          extensions: [
            ".native.ts",
            ".native.tsx",
            ".ts",
            ".tsx",
            ".js",
            ".jsx",
          ],
          preferBuiltins: false,
          browser: false,
        }),
        commonjs(),
        typescript({
          tsconfig: "./tsconfig.json",
          declaration: false, // Declarations already generated by web config
          declarationMap: false,
          noForceEmit: true,
        }),
        json(),
        babel({
          extensions: [".js", ".jsx", ".ts", ".tsx"],
          plugins: ["babel-plugin-react-compiler"],
          babelHelpers: "bundled",
        }),
      ],
      onwarn(warning, warn) {
        if (warning.code === "THIS_IS_UNDEFINED") return;
        warn(warning);
      },
    });
  }

  return configs;
});

export default config;
